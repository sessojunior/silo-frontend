import express from 'express'
import cors from 'cors'
import helmet from 'helmet'
import multer from 'multer'
import sharp from 'sharp'
import { fileTypeFromBuffer } from 'file-type'
import { v4 as uuidv4 } from 'uuid'
import path from 'path'
import fs from 'fs'
import { fileURLToPath } from 'url'
import dotenv from 'dotenv'

// Configura√ß√£o
dotenv.config()
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const app = express()
const PORT = process.env.PORT || 4000

// Middleware
app.use(
	helmet({
		contentSecurityPolicy: {
			directives: {
				defaultSrc: ["'self'"],
				imgSrc: ["'self'", 'data:', 'blob:', 'http://localhost:3000', 'http://localhost:4000'],
				styleSrc: ["'self'", "'unsafe-inline'"],
				scriptSrc: ["'self'"],
			},
		},
		crossOriginEmbedderPolicy: false,
	}),
)
app.use(
	cors({
		origin: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',
		credentials: true,
		methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
		allowedHeaders: ['Content-Type', 'Authorization'],
	}),
)
app.use(express.json())

// Configura√ß√£o Multer
const storage = multer.memoryStorage()
const upload = multer({
	storage,
	limits: {
		fileSize: parseInt(process.env.MAX_FILE_SIZE) || 4194304, // 4MB
		files: parseInt(process.env.MAX_FILES_COUNT) || 3,
	},
	fileFilter: (req, file, cb) => {
		console.log('üîµ Multer fileFilter:', {
			fieldname: file.fieldname,
			originalname: file.originalname,
			mimetype: file.mimetype,
			size: file.size,
		})

		// Valida√ß√£o b√°sica de MIME type
		const allowedMimes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif']
		if (allowedMimes.includes(file.mimetype)) {
			cb(null, true)
		} else {
			console.log('‚ùå Multer rejeitou arquivo por MIME type:', file.mimetype)
			cb(new Error('Tipo de arquivo n√£o permitido'), false)
		}
	},
})

// Fun√ß√£o para gerar nome √∫nico
function generateUniqueFilename(originalName) {
	const ext = path.extname(originalName)
	const name = path.basename(originalName, ext)
	const timestamp = Date.now()
	const random = uuidv4().substring(0, 8)
	return `${timestamp}-${random}${ext}`
}

// Fun√ß√£o para validar tipo de arquivo
async function validateFileType(buffer) {
	try {
		console.log('üîµ Iniciando valida√ß√£o de arquivo:', {
			bufferLength: buffer.length,
			firstBytes: buffer.slice(0, 10).toString('hex'),
		})

		const fileType = await fileTypeFromBuffer(buffer)
		const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif']

		console.log('üîµ Resultado da valida√ß√£o:', {
			detectedType: fileType?.mime,
			detectedExt: fileType?.ext,
			allowedTypes,
			isValid: allowedTypes.includes(fileType?.mime),
			fileTypeObject: fileType,
		})

		// Se file-type n√£o detectar ou retornar undefined, rejeitar arquivo por seguran√ßa
		if (!fileType || !fileType.mime) {
			console.log('‚ùå file-type n√£o detectou tipo, rejeitando arquivo por seguran√ßa')
			return false
		}

		const isValid = allowedTypes.includes(fileType.mime)
		console.log('‚úÖ Valida√ß√£o conclu√≠da:', { isValid, mimeType: fileType.mime })
		return isValid
	} catch (error) {
		console.error('‚ùå Erro na valida√ß√£o de tipo:', error)
		// Em caso de erro, rejeitar o arquivo por seguran√ßa
		return false
	}
}

// Fun√ß√£o para gerar thumbnail (baseada no c√≥digo existente do SILO)
async function generateThumbnail(buffer, filename) {
	try {
		const thumbFilename = `thumb-${filename.replace(/\.[^/.]+$/, '')}.webp`
		const thumbPath = path.join(__dirname, '..', 'uploads', 'avatars', thumbFilename)

		// Configura√ß√£o baseada em src/server/uploadthing.ts
		const thumbnailSize = parseInt(process.env.AVATAR_THUMBNAIL_SIZE) || 128
		const thumbnailQuality = parseInt(process.env.AVATAR_THUMBNAIL_QUALITY) || 85

		await sharp(buffer)
			.rotate() // Rota√ß√£o autom√°tica baseada em EXIF (como em profileImage.ts)
			.resize(thumbnailSize, thumbnailSize, { fit: 'cover' })
			.webp({ quality: thumbnailQuality })
			.toFile(thumbPath)

		console.log('‚úÖ Thumbnail gerado:', thumbFilename)
		return `${process.env.FILE_SERVER_URL}/files/avatars/${thumbFilename}`
	} catch (error) {
		console.error('‚ùå Erro ao gerar thumbnail:', error)
		return null
	}
}

// Fun√ß√£o para otimizar imagem geral (baseada no c√≥digo existente do SILO)
async function optimizeImage(buffer, filename, type = 'general') {
	try {
		// Substituir extens√£o original por .webp
		const optimizedFilename = filename.replace(/\.[^/.]+$/, '') + '.webp'
		const uploadDir = path.join(__dirname, '..', 'uploads', type)
		const optimizedPath = path.join(uploadDir, optimizedFilename)

		// Configura√ß√£o baseada em src/lib/profileImage.ts
		const maxWidth = parseInt(process.env.GENERAL_MAX_WIDTH) || 1920
		const maxHeight = parseInt(process.env.GENERAL_MAX_HEIGHT) || 1080
		const quality = parseInt(process.env.GENERAL_QUALITY) || 90

		await sharp(buffer)
			.rotate() // Rota√ß√£o autom√°tica baseada em EXIF
			.resize(maxWidth, maxHeight, { fit: 'inside', withoutEnlargement: true })
			.webp({ quality })
			.toFile(optimizedPath)

		console.log('‚úÖ Imagem otimizada e substitu√≠da:', optimizedFilename)
		return `${process.env.FILE_SERVER_URL}/files/${type}/${optimizedFilename}`
	} catch (error) {
		console.error('‚ùå Erro ao otimizar imagem:', error)
		return null
	}
}

// Fun√ß√£o para gerar imagem de perfil (baseada em profileImage.ts)
async function generateProfileImage(buffer, userId) {
	try {
		const profileFilename = `${userId}.webp`
		const profilePath = path.join(__dirname, '..', 'uploads', 'avatars', profileFilename)

		// Configura√ß√£o baseada em src/lib/profileImage.ts
		const profileSize = parseInt(process.env.PROFILE_IMAGE_SIZE) || 64
		const profileQuality = parseInt(process.env.PROFILE_IMAGE_QUALITY) || 85

		await sharp(buffer)
			.rotate() // Rota√ß√£o autom√°tica baseada em EXIF
			.resize(profileSize, profileSize, { fit: 'cover' })
			.webp({ quality: profileQuality })
			.toFile(profilePath)

		console.log('‚úÖ Imagem de perfil gerada:', profileFilename)
		return `${process.env.FILE_SERVER_URL}/files/avatars/${profileFilename}`
	} catch (error) {
		console.error('‚ùå Erro ao gerar imagem de perfil:', error)
		return null
	}
}

// Endpoint principal de upload
app.post('/api/upload', upload.single('file'), async (req, res) => {
	try {
		if (!req.file) {
			return res.status(400).json({ error: 'Nenhum arquivo enviado' })
		}

		// Validar tipo de arquivo
		const isValidType = await validateFileType(req.file.buffer)
		if (!isValidType) {
			return res.status(400).json({ error: 'Tipo de arquivo n√£o permitido' })
		}

		// Gerar nome √∫nico
		const filename = generateUniqueFilename(req.file.originalname)
		const uploadDir = path.join(__dirname, '..', 'uploads', 'general')

		// Garantir que diret√≥rio existe
		if (!fs.existsSync(uploadDir)) {
			fs.mkdirSync(uploadDir, { recursive: true })
		}

		// Otimizar imagem automaticamente (baseado no c√≥digo existente)
		const optimizedUrl = await optimizeImage(req.file.buffer, filename, 'general')
		const optimizedFilename = filename.replace(/\.[^/.]+$/, '') + '.webp'
		const fileUrl = optimizedUrl || `${process.env.FILE_SERVER_URL}/files/general/${optimizedFilename}`

		// Resposta padronizada
		const response = {
			key: optimizedFilename,
			name: req.file.originalname,
			size: req.file.size,
			url: fileUrl,
			// Campos adicionais
			id: optimizedFilename,
			status: 'uploaded',
			optimized: !!optimizedUrl, // Indica se foi otimizada
		}

		console.log('‚úÖ Upload conclu√≠do:', optimizedFilename)
		res.json(response)
	} catch (error) {
		console.error('‚ùå Erro no upload:', error)
		res.status(500).json({ error: 'Erro interno do servidor' })
	}
})

// Endpoint espec√≠fico para avatars
app.post('/upload/avatar', upload.single('file'), async (req, res) => {
	try {
		if (!req.file) {
			return res.status(400).json({ success: false, error: 'Nenhum arquivo enviado' })
		}

		const isValidType = await validateFileType(req.file.buffer)
		if (!isValidType) {
			return res.status(400).json({ success: false, error: 'Tipo de arquivo n√£o permitido' })
		}

		const filename = generateUniqueFilename(req.file.originalname)
		const uploadDir = path.join(__dirname, '..', 'uploads', 'avatars')

		if (!fs.existsSync(uploadDir)) {
			fs.mkdirSync(uploadDir, { recursive: true })
		}

		// Limpar avatars anteriores (manter apenas o mais recente)
		try {
			const existingFiles = fs.readdirSync(uploadDir)
			for (const file of existingFiles) {
				if (file.endsWith('.webp')) {
					const filePath = path.join(uploadDir, file)
					fs.unlinkSync(filePath)
					console.log('üóëÔ∏è Avatar anterior removido:', file)
				}
			}
		} catch (cleanupError) {
			console.log('‚ö†Ô∏è Erro ao limpar avatars anteriores:', cleanupError.message)
		}

		// Gerar avatar quadrado otimizado (baseado em src/lib/profileImage.ts)
		const optimizedFilename = filename.replace(/\.[^/.]+$/, '') + '.webp'
		const optimizedPath = path.join(uploadDir, optimizedFilename)

		const avatarSize = parseInt(process.env.PROFILE_IMAGE_SIZE) || 64
		const avatarQuality = parseInt(process.env.PROFILE_IMAGE_QUALITY) || 85

		await sharp(req.file.buffer)
			.rotate() // Rota√ß√£o autom√°tica baseada em EXIF
			.resize(avatarSize, avatarSize, { fit: 'cover' }) // Quadrado com crop
			.webp({ quality: avatarQuality })
			.toFile(optimizedPath)

		const fileUrl = `${process.env.FILE_SERVER_URL}/files/avatars/${optimizedFilename}`

		const response = {
			success: true,
			message: 'Upload de avatar conclu√≠do com sucesso!',
			data: {
				key: optimizedFilename,
				name: req.file.originalname,
				size: req.file.size,
				url: fileUrl,
				optimized: true,
			},
		}

		console.log('‚úÖ Avatar upload conclu√≠do:', optimizedFilename)
		res.json(response)
	} catch (error) {
		console.error('‚ùå Erro no upload de avatar:', error)
		res.status(500).json({ success: false, error: 'Erro interno do servidor' })
	}
})

// Endpoint para upload de contatos
app.post('/upload/contact', upload.single('file'), async (req, res) => {
	try {
		if (!req.file) {
			return res.status(400).json({ success: false, error: 'Nenhum arquivo enviado' })
		}

		const isValidType = await validateFileType(req.file.buffer)
		if (!isValidType) {
			return res.status(400).json({ success: false, error: 'Tipo de arquivo n√£o permitido' })
		}

		const filename = generateUniqueFilename(req.file.originalname)
		const uploadDir = path.join(__dirname, '..', 'uploads', 'contacts')

		if (!fs.existsSync(uploadDir)) {
			fs.mkdirSync(uploadDir, { recursive: true })
		}

		// Limpar imagens anteriores de contatos (manter apenas a mais recente)
		try {
			const existingFiles = fs.readdirSync(uploadDir)
			for (const file of existingFiles) {
				if (file.endsWith('.webp')) {
					const filePath = path.join(uploadDir, file)
					fs.unlinkSync(filePath)
					console.log('üóëÔ∏è Imagem anterior de contato removida:', file)
				}
			}
		} catch (cleanupError) {
			console.log('‚ö†Ô∏è Erro ao limpar imagens anteriores de contatos:', cleanupError.message)
		}

		// Gerar imagem quadrada otimizada (igual ao avatar)
		const optimizedFilename = filename.replace(/\.[^/.]+$/, '') + '.webp'
		const optimizedPath = path.join(uploadDir, optimizedFilename)

		const contactSize = parseInt(process.env.PROFILE_IMAGE_SIZE) || 64
		const contactQuality = parseInt(process.env.PROFILE_IMAGE_QUALITY) || 85

		await sharp(req.file.buffer)
			.rotate() // Rota√ß√£o autom√°tica baseada em EXIF
			.resize(contactSize, contactSize, { fit: 'cover' }) // Quadrado com crop
			.webp({ quality: contactQuality })
			.toFile(optimizedPath)

		const fileUrl = `${process.env.FILE_SERVER_URL}/files/contacts/${optimizedFilename}`

		const response = {
			success: true,
			message: 'Upload de contato conclu√≠do com sucesso!',
			data: {
				key: optimizedFilename,
				name: req.file.originalname,
				size: req.file.size,
				url: fileUrl,
				optimized: true,
			},
		}

		console.log('‚úÖ Contato upload conclu√≠do:', optimizedFilename)
		res.json(response)
	} catch (error) {
		console.error('‚ùå Erro no upload de contato:', error)
		res.status(500).json({ success: false, error: 'Erro interno do servidor' })
	}
})

// Endpoint para upload m√∫ltiplo de problemas
app.post('/upload/problem', upload.array('files', 3), async (req, res) => {
	try {
		if (!req.files || req.files.length === 0) {
			return res.status(400).json({ success: false, error: 'Nenhum arquivo enviado' })
		}

		const uploadedFiles = []
		const uploadDir = path.join(__dirname, '..', 'uploads', 'problems')

		if (!fs.existsSync(uploadDir)) {
			fs.mkdirSync(uploadDir, { recursive: true })
		}

		for (const file of req.files) {
			const isValidType = await validateFileType(file.buffer)
			if (!isValidType) {
				continue // Pular arquivos inv√°lidos
			}

			const filename = generateUniqueFilename(file.originalname)

			// Otimizar imagem automaticamente
			const optimizedUrl = await optimizeImage(file.buffer, filename, 'problems')
			const optimizedFilename = filename.replace(/\.[^/.]+$/, '') + '.webp'
			const fileUrl = optimizedUrl || `${process.env.FILE_SERVER_URL}/files/problems/${optimizedFilename}`

			uploadedFiles.push({
				key: optimizedFilename,
				name: file.originalname,
				size: file.size,
				url: fileUrl,
				optimized: !!optimizedUrl, // Indica se foi otimizada
			})
		}

		const response = {
			success: true,
			message: `${uploadedFiles.length} arquivo(s) de problema enviado(s) com sucesso!`,
			data: uploadedFiles,
		}

		console.log('‚úÖ Problema upload conclu√≠do:', uploadedFiles.length, 'arquivos')
		res.json(response)
	} catch (error) {
		console.error('‚ùå Erro no upload de problema:', error)
		res.status(500).json({ success: false, error: 'Erro interno do servidor' })
	}
})

// Endpoint para upload m√∫ltiplo de solu√ß√µes
app.post('/upload/solution', upload.array('files', 3), async (req, res) => {
	try {
		if (!req.files || req.files.length === 0) {
			return res.status(400).json({ success: false, error: 'Nenhum arquivo enviado' })
		}

		const uploadedFiles = []
		const uploadDir = path.join(__dirname, '..', 'uploads', 'solutions')

		if (!fs.existsSync(uploadDir)) {
			fs.mkdirSync(uploadDir, { recursive: true })
		}

		for (const file of req.files) {
			const isValidType = await validateFileType(file.buffer)
			if (!isValidType) {
				continue // Pular arquivos inv√°lidos
			}

			const filename = generateUniqueFilename(file.originalname)

			// Otimizar imagem automaticamente
			const optimizedUrl = await optimizeImage(file.buffer, filename, 'solutions')
			const optimizedFilename = filename.replace(/\.[^/.]+$/, '') + '.webp'
			const fileUrl = optimizedUrl || `${process.env.FILE_SERVER_URL}/files/solutions/${optimizedFilename}`

			uploadedFiles.push({
				key: optimizedFilename,
				name: file.originalname,
				size: file.size,
				url: fileUrl,
				optimized: !!optimizedUrl, // Indica se foi otimizada
			})
		}

		const response = {
			success: true,
			message: `${uploadedFiles.length} arquivo(s) de solu√ß√£o enviado(s) com sucesso!`,
			data: uploadedFiles,
		}

		console.log('‚úÖ Solu√ß√£o upload conclu√≠do:', uploadedFiles.length, 'arquivos')
		res.json(response)
	} catch (error) {
		console.error('‚ùå Erro no upload de solu√ß√£o:', error)
		res.status(500).json({ success: false, error: 'Erro interno do servidor' })
	}
})

// Preflight OPTIONS para arquivos
app.options('/files/:type/:filename', (req, res) => {
	res.header('Access-Control-Allow-Origin', process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000')
	res.header('Access-Control-Allow-Credentials', 'true')
	res.header('Access-Control-Allow-Methods', 'GET, OPTIONS')
	res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept')
	res.header('Cross-Origin-Resource-Policy', 'cross-origin')
	res.status(200).end()
})

// Endpoint para servir arquivos
app.get('/files/:type/:filename', (req, res) => {
	const { type, filename } = req.params
	const filePath = path.join(__dirname, '..', 'uploads', type, filename)

	// Headers CORS espec√≠ficos para arquivos
	res.header('Access-Control-Allow-Origin', process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000')
	res.header('Access-Control-Allow-Credentials', 'true')
	res.header('Access-Control-Allow-Methods', 'GET, OPTIONS')
	res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept')
	res.header('Cross-Origin-Resource-Policy', 'cross-origin')

	if (fs.existsSync(filePath)) {
		res.sendFile(filePath)
	} else {
		res.status(404).json({ error: 'Arquivo n√£o encontrado' })
	}
})

// Endpoint para deletar arquivos
app.delete('/files/:type/:filename', (req, res) => {
	const { type, filename } = req.params
	const filePath = path.join(__dirname, '..', 'uploads', type, filename)

	try {
		if (fs.existsSync(filePath)) {
			fs.unlinkSync(filePath)
			res.json({ success: true, message: 'Arquivo deletado com sucesso' })
		} else {
			res.status(404).json({ success: false, error: 'Arquivo n√£o encontrado' })
		}
	} catch (error) {
		console.error('‚ùå Erro ao deletar arquivo:', error)
		res.status(500).json({ success: false, error: 'Erro interno do servidor' })
	}
})

// Health check
app.get('/health', (req, res) => {
	res.json({
		success: true,
		message: 'Servidor de arquivos funcionando',
		timestamp: new Date().toISOString(),
		port: PORT,
	})
})

// Fun√ß√£o para limpeza autom√°tica de arquivos tempor√°rios
function cleanupTempFiles() {
	const tempDir = path.join(__dirname, '..', 'uploads', 'temp')
	if (fs.existsSync(tempDir)) {
		const files = fs.readdirSync(tempDir)
		const now = Date.now()
		const maxAge = 24 * 60 * 60 * 1000 // 24 horas

		files.forEach((file) => {
			const filePath = path.join(tempDir, file)
			const stats = fs.statSync(filePath)

			if (now - stats.mtime.getTime() > maxAge) {
				fs.unlinkSync(filePath)
				console.log('üóëÔ∏è Arquivo tempor√°rio removido:', file)
			}
		})
	}
}

// Limpeza autom√°tica a cada hora
setInterval(cleanupTempFiles, 60 * 60 * 1000)

// Iniciar servidor
app.listen(PORT, () => {
	console.log(`üöÄ Servidor de arquivos SILO rodando na porta ${PORT}`)
	console.log(`üìÅ Uploads em: ${path.join(__dirname, '..', 'uploads')}`)
	console.log(`üîó URL: ${process.env.FILE_SERVER_URL}`)
	console.log(`üóëÔ∏è Limpeza autom√°tica de arquivos tempor√°rios ativada`)
})
